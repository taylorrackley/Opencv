<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Container Detection Demo</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; font-family: Arial, sans-serif; }
        canvas { border: 1px solid black; max-width: 100%; }
        #output { margin-top: 10px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script>eruda.init();</script>
</head>
<body>
    <h2>Upload an Image</h2>
    <input type="file" id="imageInput" accept="image/*">
    <canvas id="canvas"></canvas>
    <div id="output"></div>

    <script type="text/javascript">
        let containers = [];
        let scaleFactor = 1;

        function onOpenCvReady() {
            console.log('OpenCV.js is ready');
            alert('OpenCV.js is ready');
            if (typeof cv === 'undefined') {
                console.error('OpenCV.js failed to load');
                document.getElementById('output').innerText = 'Error: OpenCV.js not loaded';
                return;
            }
            document.getElementById('imageInput').addEventListener('change', handleImageUpload);
        }

        function handleImageUpload(event) {
            console.log('File selected:', event.target.files[0]);
            const file = event.target.files[0];
            if (!file) return;

            const imgElement = new Image();
            imgElement.onload = () => {
                console.log('Image loaded:', imgElement.width, imgElement.height);
                processImage(imgElement);
            };
            imgElement.src = URL.createObjectURL(file);
        }

        function processImage(imgElement) {
            console.log('Processing image...');
            let canvas = document.getElementById('canvas');
            let ctx = canvas.getContext('2d');

            // Scale down the image for better performance
            const maxWidth = 800; // Adjust as needed
            scaleFactor = maxWidth / imgElement.width;
            canvas.width = maxWidth;
            canvas.height = imgElement.height * scaleFactor;
            ctx.drawImage(imgElement, 0, 0, canvas.width, canvas.height);

            // Process with OpenCV
            let src = cv.imread(canvas);
            let gray = new cv.Mat();
            let edges = new cv.Mat();

            // Increase contrast to better detect drawers
            let equalized = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            cv.equalizeHist(gray, equalized);
            cv.Canny(equalized, edges, 50, 150); // Adjusted thresholds

            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

            containers = [];
            console.log('Detecting containers...');
            for (let i = 0; i < contours.size(); i++) {
                let contour = contours.get(i);
                let rect = cv.boundingRect(contour);
                // Scale coordinates to match canvas
                rect.x = rect.x * scaleFactor;
                rect.y = rect.y * scaleFactor;
                rect.width = rect.width * scaleFactor;
                rect.height = rect.height * scaleFactor;
                // Filter by size and aspect ratio (drawers are typically wider than tall)
                if (rect.width > 30 && rect.height > 20 && rect.width > rect.height) {
                    containers.push(rect);
                    console.log(`Detected rect at (${rect.x}, ${rect.y}), w=${rect.width}, h=${rect.height}`);
                }
            }

            // Draw using canvas 2D only (bypass cv.imshow issues)
            console.log('Drawing rectangles with canvas 2D...');
            ctx.strokeStyle = 'green';
            ctx.lineWidth = 2;
            containers.forEach(rect => {
                ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
            });

            // Test drawing a single rectangle to confirm rendering
            console.log('Drawing test rectangle...');
            ctx.strokeStyle = 'blue';
            ctx.strokeRect(10, 10, 50, 50); // Small blue square in top-left corner

            canvas.addEventListener('touchstart', handleTap);

            src.delete(); gray.delete(); edges.delete(); equalized.delete(); contours.delete(); hierarchy.delete();
        }

        function handleTap(event) {
            event.preventDefault();
            let canvas = document.getElementById('canvas');
            let rect = canvas.getBoundingClientRect();
            let x = event.touches[0].clientX - rect.left;
            let y = event.touches[0].clientY - rect.top;

            let selected = containers.find(c => 
                x >= c.x && x <= c.x + c.width && 
                y >= c.y && y <= c.y + c.height
            );

            let output = document.getElementById('output');
            if (selected) {
                output.innerText = `Selected container at (${Math.round(selected.x)}, ${Math.round(selected.y)})`;
                console.log(`Selected: x=${selected.x}, y=${selected.y}, w=${selected.width}, h=${selected.height}`);
            } else {
                output.innerText = 'No container selected';
            }
        }
    </script>

    <script src="https://docs.opencv.org/4.5.5/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
</body>
</html>
